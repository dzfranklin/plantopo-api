// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/paulmach/orb/geojson"
)

const deleteTrack = `-- name: DeleteTrack :exec
DELETE
FROM tracks
WHERE id = $1
`

func (q *Queries) DeleteTrack(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTrack, id)
	return err
}

const deleteTrackImport = `-- name: DeleteTrackImport :exec
DELETE FROM track_imports
WHERE id = $1
`

func (q *Queries) DeleteTrackImport(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTrackImport, id)
	return err
}

const getTrack = `-- name: GetTrack :one
SELECT id, owner_id, name, upload_time, time, geojson, import_id
FROM tracks
WHERE id = $1
`

func (q *Queries) GetTrack(ctx context.Context, id int64) (Track, error) {
	row := q.db.QueryRow(ctx, getTrack, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.UploadTime,
		&i.Time,
		&i.Geojson,
		&i.ImportID,
	)
	return i, err
}

const getTrackImport = `-- name: GetTrackImport :one
SELECT id, owner_id, hash, inserted_at, completed_at, failed_at, error, filename, data
FROM track_imports
WHERE id = $1
`

func (q *Queries) GetTrackImport(ctx context.Context, id int64) (TrackImport, error) {
	row := q.db.QueryRow(ctx, getTrackImport, id)
	var i TrackImport
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Hash,
		&i.InsertedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.Error,
		&i.Filename,
		&i.Data,
	)
	return i, err
}

const getTrackImportID = `-- name: GetTrackImportID :one
SELECT import_id
FROM tracks
WHERE id = $1
`

func (q *Queries) GetTrackImportID(ctx context.Context, id int64) (*int64, error) {
	row := q.db.QueryRow(ctx, getTrackImportID, id)
	var import_id *int64
	err := row.Scan(&import_id)
	return import_id, err
}

const getTrackImportStatus = `-- name: GetTrackImportStatus :one
SELECT hash,
       owner_id,
       inserted_at,
       completed_at,
       failed_at,
       error,
       filename,
       length(data) as byte_size
FROM track_imports
WHERE id = $1
`

type GetTrackImportStatusRow struct {
	Hash        []byte           `json:"hash"`
	OwnerID     string           `json:"ownerID"`
	InsertedAt  pgtype.Timestamp `json:"insertedAt"`
	CompletedAt pgtype.Timestamp `json:"completedAt"`
	FailedAt    pgtype.Timestamp `json:"failedAt"`
	Error       *string          `json:"error"`
	Filename    string           `json:"filename"`
	ByteSize    int32            `json:"byteSize"`
}

func (q *Queries) GetTrackImportStatus(ctx context.Context, id int64) (GetTrackImportStatusRow, error) {
	row := q.db.QueryRow(ctx, getTrackImportStatus, id)
	var i GetTrackImportStatusRow
	err := row.Scan(
		&i.Hash,
		&i.OwnerID,
		&i.InsertedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.Error,
		&i.Filename,
		&i.ByteSize,
	)
	return i, err
}

const getTrackOwner = `-- name: GetTrackOwner :one
SELECT owner_id
FROM tracks
WHERE id = $1
`

func (q *Queries) GetTrackOwner(ctx context.Context, id int64) (*string, error) {
	row := q.db.QueryRow(ctx, getTrackOwner, id)
	var owner_id *string
	err := row.Scan(&owner_id)
	return owner_id, err
}

const getUnitSettings = `-- name: GetUnitSettings :one
SELECT value
FROM unit_settings
WHERE user_id = $1
`

func (q *Queries) GetUnitSettings(ctx context.Context, userID string) (json.RawMessage, error) {
	row := q.db.QueryRow(ctx, getUnitSettings, userID)
	var value json.RawMessage
	err := row.Scan(&value)
	return value, err
}

const hasImportedTrack = `-- name: HasImportedTrack :one
SELECT EXISTS(
    SELECT 1
    FROM tracks t
    JOIN track_imports ti ON t.import_id = ti.id
    WHERE t.owner_id = $1 AND
      ti.owner_id = $2 AND
      ti.hash = $3
)
`

type HasImportedTrackParams struct {
	OwnerID   *string `json:"ownerID"`
	OwnerID_2 string  `json:"ownerID2"`
	Hash      []byte  `json:"hash"`
}

func (q *Queries) HasImportedTrack(ctx context.Context, arg HasImportedTrackParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasImportedTrack, arg.OwnerID, arg.OwnerID_2, arg.Hash)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertImportedTrack = `-- name: InsertImportedTrack :one
INSERT INTO tracks
    (owner_id, name, upload_time, time, geojson, import_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type InsertImportedTrackParams struct {
	OwnerID    *string          `json:"ownerID"`
	Name       *string          `json:"name"`
	UploadTime pgtype.Timestamp `json:"uploadTime"`
	Time       pgtype.Timestamp `json:"time"`
	Geojson    geojson.Feature  `json:"geojson"`
	ImportID   *int64           `json:"importID"`
}

func (q *Queries) InsertImportedTrack(ctx context.Context, arg InsertImportedTrackParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertImportedTrack,
		arg.OwnerID,
		arg.Name,
		arg.UploadTime,
		arg.Time,
		arg.Geojson,
		arg.ImportID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertTrackImport = `-- name: InsertTrackImport :one
INSERT INTO track_imports (owner_id, filename, data, hash)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type InsertTrackImportParams struct {
	OwnerID  string `json:"ownerID"`
	Filename string `json:"filename"`
	Data     []byte `json:"data"`
	Hash     []byte `json:"hash"`
}

func (q *Queries) InsertTrackImport(ctx context.Context, arg InsertTrackImportParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertTrackImport,
		arg.OwnerID,
		arg.Filename,
		arg.Data,
		arg.Hash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listMyPendingOrRecentImports = `-- name: ListMyPendingOrRecentImports :many
SELECT hash,
       owner_id,
       inserted_at,
       completed_at,
       failed_at,
       error,
       filename,
       length(data) as byte_size
FROM track_imports
WHERE owner_id = $1
  AND (completed_at IS NULL OR
       completed_at > NOW() - INTERVAL '1 DAY' OR
       failed_at > NOW() - INTERVAL '1 DAY')
ORDER BY inserted_at DESC
`

type ListMyPendingOrRecentImportsRow struct {
	Hash        []byte           `json:"hash"`
	OwnerID     string           `json:"ownerID"`
	InsertedAt  pgtype.Timestamp `json:"insertedAt"`
	CompletedAt pgtype.Timestamp `json:"completedAt"`
	FailedAt    pgtype.Timestamp `json:"failedAt"`
	Error       *string          `json:"error"`
	Filename    string           `json:"filename"`
	ByteSize    int32            `json:"byteSize"`
}

func (q *Queries) ListMyPendingOrRecentImports(ctx context.Context, ownerID string) ([]ListMyPendingOrRecentImportsRow, error) {
	rows, err := q.db.Query(ctx, listMyPendingOrRecentImports, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMyPendingOrRecentImportsRow{}
	for rows.Next() {
		var i ListMyPendingOrRecentImportsRow
		if err := rows.Scan(
			&i.Hash,
			&i.OwnerID,
			&i.InsertedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.Error,
			&i.Filename,
			&i.ByteSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksOrderByTime = `-- name: ListTracksOrderByTime :many
SELECT id, owner_id, name, upload_time, time, geojson, import_id
FROM tracks
WHERE owner_id = $1
ORDER BY time DESC
`

func (q *Queries) ListTracksOrderByTime(ctx context.Context, ownerID *string) ([]Track, error) {
	rows, err := q.db.Query(ctx, listTracksOrderByTime, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.UploadTime,
			&i.Time,
			&i.Geojson,
			&i.ImportID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTrackImportCompleted = `-- name: MarkTrackImportCompleted :exec
UPDATE track_imports
SET completed_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkTrackImportCompleted(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markTrackImportCompleted, id)
	return err
}

const markTrackImportFailed = `-- name: MarkTrackImportFailed :exec
UPDATE track_imports
SET failed_at = NOW(),
    error     = $2
WHERE id = $1
`

type MarkTrackImportFailedParams struct {
	ID    int64   `json:"id"`
	Error *string `json:"error"`
}

func (q *Queries) MarkTrackImportFailed(ctx context.Context, arg MarkTrackImportFailedParams) error {
	_, err := q.db.Exec(ctx, markTrackImportFailed, arg.ID, arg.Error)
	return err
}

const setUnitSettings = `-- name: SetUnitSettings :exec
INSERT INTO unit_settings (user_id, value)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE
SET value = $2
`

type SetUnitSettingsParams struct {
	UserID string          `json:"userID"`
	Value  json.RawMessage `json:"value"`
}

func (q *Queries) SetUnitSettings(ctx context.Context, arg SetUnitSettingsParams) error {
	_, err := q.db.Exec(ctx, setUnitSettings, arg.UserID, arg.Value)
	return err
}
